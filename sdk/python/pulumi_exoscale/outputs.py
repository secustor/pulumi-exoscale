# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'DatabaseKafka',
    'DatabaseMysql',
    'DatabasePg',
    'DatabaseRedis',
    'ElasticIPHealthcheck',
    'NLBServiceHealthcheck',
    'SKSClusterOidc',
    'SecurityGroupRulesEgress',
    'SecurityGroupRulesIngress',
    'GetDomainRecordFilterResult',
    'GetDomainRecordRecordResult',
    'GetElasticIPHealthcheckResult',
]

@pulumi.output_type
class DatabaseKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[bool] = None,
                 enable_kafka_connect: Optional[bool] = None,
                 enable_kafka_rest: Optional[bool] = None,
                 enable_sasl_auth: Optional[bool] = None,
                 enable_schema_registry: Optional[bool] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect_settings: Optional[str] = None,
                 kafka_rest_settings: Optional[str] = None,
                 kafka_settings: Optional[str] = None,
                 schema_registry_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param bool enable_cert_auth: Enable certificate-based authentication method.
        :param bool enable_kafka_connect: Enable Kafka Connect.
        :param bool enable_kafka_rest: Enable Kafka REST.
        :param bool enable_sasl_auth: Enable SASL-based authentication method.
        :param bool enable_schema_registry: Enable Schema Registry.
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param str kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param str kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param str schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param str version: PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
        """
        if enable_cert_auth is not None:
            pulumi.set(__self__, "enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            pulumi.set(__self__, "enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            pulumi.set(__self__, "enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            pulumi.set(__self__, "enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            pulumi.set(__self__, "enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            pulumi.set(__self__, "kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            pulumi.set(__self__, "kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            pulumi.set(__self__, "kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            pulumi.set(__self__, "schema_registry_settings", schema_registry_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[bool]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[bool]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[bool]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[bool]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[bool]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[str]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[str]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[str]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[str]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 mysql_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password. Can only be set during creation.
        :param str admin_username: A custom administrator account username. Can only be set during creation.
        :param str backup_schedule: The automated backup schedule (format: HH:MM).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param str version: PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if mysql_settings is not None:
            pulumi.set(__self__, "mysql_settings", mysql_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password. Can only be set during creation.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username. Can only be set during creation.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (format: HH:MM).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[str]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabasePg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 pg_settings: Optional[str] = None,
                 pgbouncer_settings: Optional[str] = None,
                 pglookout_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password. Can only be set during creation.
        :param str admin_username: A custom administrator account username. Can only be set during creation.
        :param str backup_schedule: The automated backup schedule (format: HH:MM).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param str version: PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if backup_schedule is not None:
            pulumi.set(__self__, "backup_schedule", backup_schedule)
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if pg_settings is not None:
            pulumi.set(__self__, "pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            pulumi.set(__self__, "pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            pulumi.set(__self__, "pglookout_settings", pglookout_settings)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password. Can only be set during creation.
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username. Can only be set during creation.
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (format: HH:MM).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[str]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[str]:
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[str]:
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 redis_settings: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        if ip_filters is not None:
            pulumi.set(__self__, "ip_filters", ip_filters)
        if redis_settings is not None:
            pulumi.set(__self__, "redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[str]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class ElasticIPHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strikesFail":
            suggest = "strikes_fail"
        elif key == "strikesOk":
            suggest = "strikes_ok"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"
        elif key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticIPHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticIPHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticIPHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 port: int,
                 interval: Optional[int] = None,
                 strikes_fail: Optional[int] = None,
                 strikes_ok: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_skip_verify: Optional[bool] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str mode: The health checking mode (`supported values: `tcp`, `http`, `https`).
        :param int port: The health checking port (must be between `1` and `65535`).
        :param int interval: The health checking interval in seconds (must be between `5` and `300`; default: `10`).
        :param int strikes_fail: The number of failed attempts before considering a managed Elastic IP target unhealthy (must be between `1` and `20`).
        :param int strikes_ok: The number of successful attempts before considering a managed Elastic IP target healthy (must be between `1` and `20`).
        :param int timeout: The time in seconds before considering a healthcheck probing failed (must be between `2` and `60`; default: `3`).
        :param bool tls_skip_verify: Disable TLS certificate verification for health checking in `https` mode.
        :param str tls_sni: The health checking server name to present with SNI in `https` mode.
        :param str uri: The health checking URI (required in `http(s)` modes).
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if strikes_fail is not None:
            pulumi.set(__self__, "strikes_fail", strikes_fail)
        if strikes_ok is not None:
            pulumi.set(__self__, "strikes_ok", strikes_ok)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The health checking mode (`supported values: `tcp`, `http`, `https`).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The health checking port (must be between `1` and `65535`).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The health checking interval in seconds (must be between `5` and `300`; default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[int]:
        """
        The number of failed attempts before considering a managed Elastic IP target unhealthy (must be between `1` and `20`).
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[int]:
        """
        The number of successful attempts before considering a managed Elastic IP target healthy (must be between `1` and `20`).
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time in seconds before considering a healthcheck probing failed (must be between `2` and `60`; default: `3`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        """
        Disable TLS certificate verification for health checking in `https` mode.
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        """
        The health checking server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The health checking URI (required in `http(s)` modes).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class NLBServiceHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NLBServiceHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NLBServiceHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NLBServiceHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 interval: Optional[int] = None,
                 mode: Optional[str] = None,
                 retries: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param int port: The healthcheck port.
        :param int interval: The healthcheck interval in seconds.
        :param str mode: The healthcheck mode (`tcp`|`http`|`https`).
        :param int retries: The healthcheck retries.
        :param int timeout: The healthcheck timeout in seconds.
        :param str tls_sni: The healthcheck TLS SNI server name, only if `mode` is `https`.
        :param str uri: The healthcheck URI, must be set only if `mode` is `http(s)`.
        """
        pulumi.set(__self__, "port", port)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_sni is not None:
            pulumi.set(__self__, "tls_sni", tls_sni)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The healthcheck port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The healthcheck interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The healthcheck mode (`tcp`|`http`|`https`).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The healthcheck retries.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The healthcheck timeout in seconds.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        """
        The healthcheck TLS SNI server name, only if `mode` is `https`.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The healthcheck URI, must be set only if `mode` is `http(s)`.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class SKSClusterOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaim":
            suggest = "groups_claim"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaim":
            suggest = "required_claim"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SKSClusterOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SKSClusterOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SKSClusterOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "issuer_url", issuer_url)
        if groups_claim is not None:
            pulumi.set(__self__, "groups_claim", groups_claim)
        if groups_prefix is not None:
            pulumi.set(__self__, "groups_prefix", groups_prefix)
        if required_claim is not None:
            pulumi.set(__self__, "required_claim", required_claim)
        if username_claim is not None:
            pulumi.set(__self__, "username_claim", username_claim)
        if username_prefix is not None:
            pulumi.set(__self__, "username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class SecurityGroupRulesEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrLists":
            suggest = "cidr_lists"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "userSecurityGroupLists":
            suggest = "user_security_group_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupRulesEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupRulesEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupRulesEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_lists: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ids: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 user_security_group_lists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] cidr_lists: A list of source (for ingress)/destination (for egress) IP subnet (in [CIDR notation][cidr]) to match.
        :param str description: A free-form text describing the Security Group rule purpose.
        :param Sequence[str] ports: A list of ports or port ranges (`start_port-end_port`).
               * `icmp_type`/`icmp_code` - An ICMP/ICMPv6 [type/code][icmp] to match.
        :param str protocol: The network protocol to match. Supported values are: `TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` and `ALL`.
        :param Sequence[str] user_security_group_lists: A source (for ingress)/destination (for egress) of the traffic identified by a Security Group.
        """
        if cidr_lists is not None:
            pulumi.set(__self__, "cidr_lists", cidr_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_security_group_lists is not None:
            pulumi.set(__self__, "user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[Sequence[str]]:
        """
        A list of source (for ingress)/destination (for egress) IP subnet (in [CIDR notation][cidr]) to match.
        """
        return pulumi.get(self, "cidr_lists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A free-form text describing the Security Group rule purpose.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        A list of ports or port ranges (`start_port-end_port`).
        * `icmp_type`/`icmp_code` - An ICMP/ICMPv6 [type/code][icmp] to match.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The network protocol to match. Supported values are: `TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` and `ALL`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[Sequence[str]]:
        """
        A source (for ingress)/destination (for egress) of the traffic identified by a Security Group.
        """
        return pulumi.get(self, "user_security_group_lists")


@pulumi.output_type
class SecurityGroupRulesIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrLists":
            suggest = "cidr_lists"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "userSecurityGroupLists":
            suggest = "user_security_group_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupRulesIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupRulesIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupRulesIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_lists: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ids: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 user_security_group_lists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] cidr_lists: A list of source (for ingress)/destination (for egress) IP subnet (in [CIDR notation][cidr]) to match.
        :param str description: A free-form text describing the Security Group rule purpose.
        :param Sequence[str] ports: A list of ports or port ranges (`start_port-end_port`).
               * `icmp_type`/`icmp_code` - An ICMP/ICMPv6 [type/code][icmp] to match.
        :param str protocol: The network protocol to match. Supported values are: `TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` and `ALL`.
        :param Sequence[str] user_security_group_lists: A source (for ingress)/destination (for egress) of the traffic identified by a Security Group.
        """
        if cidr_lists is not None:
            pulumi.set(__self__, "cidr_lists", cidr_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if user_security_group_lists is not None:
            pulumi.set(__self__, "user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[Sequence[str]]:
        """
        A list of source (for ingress)/destination (for egress) IP subnet (in [CIDR notation][cidr]) to match.
        """
        return pulumi.get(self, "cidr_lists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A free-form text describing the Security Group rule purpose.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        A list of ports or port ranges (`start_port-end_port`).
        * `icmp_type`/`icmp_code` - An ICMP/ICMPv6 [type/code][icmp] to match.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The network protocol to match. Supported values are: `TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` and `ALL`.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[Sequence[str]]:
        """
        A source (for ingress)/destination (for egress) of the traffic identified by a Security Group.
        """
        return pulumi.get(self, "user_security_group_lists")


@pulumi.output_type
class GetDomainRecordFilterResult(dict):
    def __init__(__self__, *,
                 content_regex: Optional[str] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 record_type: Optional[str] = None):
        """
        :param str content_regex: A regular expression matching the domain record content to lookup.
        :param int id: The ID matching the domain record ID to lookup.
        :param str name: The name matching the domain record name to lookup.
        :param str record_type: The record type matching the domain record type to lookup.
        """
        if content_regex is not None:
            pulumi.set(__self__, "content_regex", content_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[str]:
        """
        A regular expression matching the domain record content to lookup.
        """
        return pulumi.get(self, "content_regex")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID matching the domain record ID to lookup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name matching the domain record name to lookup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        The record type matching the domain record type to lookup.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class GetDomainRecordRecordResult(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 domain: Optional[str] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 prio: Optional[int] = None,
                 record_type: Optional[str] = None):
        """
        :param str content: The content of the domain record.
        :param str domain: The name of the [domain][r-domain] where to look for domain records.
        :param int id: The ID matching the domain record ID to lookup.
        :param str name: The name matching the domain record name to lookup.
        :param int prio: The priority of the domain record.
        :param str record_type: The record type matching the domain record type to lookup.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prio is not None:
            pulumi.set(__self__, "prio", prio)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        The content of the domain record.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The name of the [domain][r-domain] where to look for domain records.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID matching the domain record ID to lookup.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name matching the domain record name to lookup.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prio(self) -> Optional[int]:
        """
        The priority of the domain record.
        """
        return pulumi.get(self, "prio")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        The record type matching the domain record type to lookup.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class GetElasticIPHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 strikes_fail: int,
                 strikes_ok: int,
                 timeout: int,
                 tls_skip_verify: bool,
                 tls_sni: str,
                 uri: str):
        """
        :param int interval: The health checking interval in seconds.
        :param str mode: (Required) The health checking mode.
        :param int port: (Required) The health checking port.
        :param int strikes_fail: The number of failed attempts before considering a managed Elastic IP target unhealthy.
        :param int strikes_ok: The number of successful attempts before considering a managed Elastic IP target healthy.
        :param int timeout: The time in seconds before considering a healthcheck probing failed.
        :param bool tls_skip_verify: Disable TLS certificate verification for health checking in `https` mode.
        :param str tls_sni: The health checking server name to present with SNI in `https` mode.
        :param str uri: The health checking URI.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "strikes_fail", strikes_fail)
        pulumi.set(__self__, "strikes_ok", strikes_ok)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        pulumi.set(__self__, "tls_sni", tls_sni)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        """
        The health checking interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        (Required) The health checking mode.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        (Required) The health checking port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> int:
        """
        The number of failed attempts before considering a managed Elastic IP target unhealthy.
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> int:
        """
        The number of successful attempts before considering a managed Elastic IP target healthy.
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The time in seconds before considering a healthcheck probing failed.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> bool:
        """
        Disable TLS certificate verification for health checking in `https` mode.
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        """
        The health checking server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The health checking URI.
        """
        return pulumi.get(self, "uri")


