// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface DatabaseKafka {
    /**
     * Enable certificate-based authentication method.
     */
    enableCertAuth: boolean;
    /**
     * Enable Kafka Connect.
     */
    enableKafkaConnect?: boolean;
    /**
     * Enable Kafka REST.
     */
    enableKafkaRest?: boolean;
    /**
     * Enable SASL-based authentication method.
     */
    enableSaslAuth: boolean;
    /**
     * Enable Schema Registry.
     */
    enableSchemaRegistry?: boolean;
    /**
     * A list of CIDR blocks to allow incoming connections from.
     */
    ipFilters: string[];
    /**
     * Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
     */
    kafkaConnectSettings: string;
    /**
     * Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
     */
    kafkaRestSettings: string;
    /**
     * Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
     */
    kafkaSettings: string;
    /**
     * Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
     */
    schemaRegistrySettings: string;
    /**
     * PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
     */
    version: string;
}

export interface DatabaseMysql {
    /**
     * A custom administrator account password. Can only be set during creation.
     */
    adminPassword: string;
    /**
     * A custom administrator account username. Can only be set during creation.
     */
    adminUsername: string;
    /**
     * The automated backup schedule (format: HH:MM).
     */
    backupSchedule: string;
    /**
     * A list of CIDR blocks to allow incoming connections from.
     */
    ipFilters: string[];
    /**
     * MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
     */
    mysqlSettings: string;
    /**
     * PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
     */
    version: string;
}

export interface DatabasePg {
    /**
     * A custom administrator account password. Can only be set during creation.
     */
    adminPassword: string;
    /**
     * A custom administrator account username. Can only be set during creation.
     */
    adminUsername: string;
    /**
     * The automated backup schedule (format: HH:MM).
     */
    backupSchedule: string;
    /**
     * A list of CIDR blocks to allow incoming connections from.
     */
    ipFilters: string[];
    /**
     * PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
     */
    pgSettings: string;
    pgbouncerSettings: string;
    pglookoutSettings: string;
    /**
     * PostgreSQL major version (`exo dbaas type show pg` for reference). Can only be set during creation.
     */
    version: string;
}

export interface DatabaseRedis {
    /**
     * A list of CIDR blocks to allow incoming connections from.
     */
    ipFilters: string[];
    /**
     * Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
     */
    redisSettings: string;
}

export interface ElasticIPHealthcheck {
    /**
     * The health checking interval in seconds (must be between `5` and `300`; default: `10`).
     */
    interval?: number;
    /**
     * The health checking mode (`supported values: `tcp`, `http`, `https`).
     */
    mode: string;
    /**
     * The health checking port (must be between `1` and `65535`).
     */
    port: number;
    /**
     * The number of failed attempts before considering a managed Elastic IP target unhealthy (must be between `1` and `20`).
     */
    strikesFail?: number;
    /**
     * The number of successful attempts before considering a managed Elastic IP target healthy (must be between `1` and `20`).
     */
    strikesOk?: number;
    /**
     * The time in seconds before considering a healthcheck probing failed (must be between `2` and `60`; default: `3`).
     */
    timeout?: number;
    /**
     * Disable TLS certificate verification for health checking in `https` mode.
     */
    tlsSkipVerify?: boolean;
    /**
     * The health checking server name to present with SNI in `https` mode.
     */
    tlsSni?: string;
    /**
     * The health checking URI (required in `http(s)` modes).
     */
    uri?: string;
}

export interface GetDomainRecordFilter {
    /**
     * A regular expression matching the domain record content to lookup.
     */
    contentRegex?: string;
    /**
     * The ID matching the domain record ID to lookup.
     */
    id?: number;
    /**
     * The name matching the domain record name to lookup.
     */
    name?: string;
    /**
     * The record type matching the domain record type to lookup.
     */
    recordType?: string;
}

export interface GetDomainRecordRecord {
    /**
     * The content of the domain record.
     */
    content?: string;
    /**
     * The name of the [domain][r-domain] where to look for domain records.
     */
    domain?: string;
    /**
     * The ID matching the domain record ID to lookup.
     */
    id?: number;
    /**
     * The name matching the domain record name to lookup.
     */
    name?: string;
    /**
     * The priority of the domain record.
     */
    prio?: number;
    /**
     * The record type matching the domain record type to lookup.
     */
    recordType?: string;
}

export interface GetElasticIPHealthcheck {
    /**
     * The health checking interval in seconds.
     */
    interval: number;
    /**
     * (Required) The health checking mode.
     */
    mode: string;
    /**
     * (Required) The health checking port.
     */
    port: number;
    /**
     * The number of failed attempts before considering a managed Elastic IP target unhealthy.
     */
    strikesFail: number;
    /**
     * The number of successful attempts before considering a managed Elastic IP target healthy.
     */
    strikesOk: number;
    /**
     * The time in seconds before considering a healthcheck probing failed.
     */
    timeout: number;
    /**
     * Disable TLS certificate verification for health checking in `https` mode.
     */
    tlsSkipVerify: boolean;
    /**
     * The health checking server name to present with SNI in `https` mode.
     */
    tlsSni: string;
    /**
     * The health checking URI.
     */
    uri: string;
}

export interface NLBServiceHealthcheck {
    /**
     * The healthcheck interval in seconds.
     */
    interval?: number;
    /**
     * The healthcheck mode (`tcp`|`http`|`https`).
     */
    mode?: string;
    /**
     * The healthcheck port.
     */
    port: number;
    /**
     * The healthcheck retries.
     */
    retries?: number;
    /**
     * The healthcheck timeout in seconds.
     */
    timeout?: number;
    /**
     * The healthcheck TLS SNI server name, only if `mode` is `https`.
     */
    tlsSni?: string;
    /**
     * The healthcheck URI, must be set only if `mode` is `http(s)`.
     */
    uri?: string;
}

export interface SKSClusterOidc {
    /**
     * The OpenID client ID.
     */
    clientId: string;
    /**
     * An OpenID JWT claim to use as the user's group.
     */
    groupsClaim?: string;
    /**
     * An OpenID prefix prepended to group claims.
     */
    groupsPrefix?: string;
    /**
     * The OpenID provider URL.
     */
    issuerUrl: string;
    /**
     * A map of key/value pairs that describes a required claim in the OpenID Token.
     */
    requiredClaim?: {[key: string]: string};
    /**
     * An OpenID JWT claim to use as the user name.
     */
    usernameClaim?: string;
    /**
     * An OpenID prefix prepended to username claims.
     */
    usernamePrefix?: string;
}

export interface SecurityGroupRulesEgress {
    /**
     * A list of source (for ingress)/destination (for egress) IP subnet (in [CIDR notation][cidr]) to match.
     */
    cidrLists?: string[];
    /**
     * A free-form text describing the Security Group rule purpose.
     */
    description?: string;
    icmpCode?: number;
    icmpType?: number;
    ids: string[];
    /**
     * A list of ports or port ranges (`start_port-end_port`).
     * * `icmpType`/`icmpCode` - An ICMP/ICMPv6 [type/code][icmp] to match.
     */
    ports?: string[];
    /**
     * The network protocol to match. Supported values are: `TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` and `ALL`.
     */
    protocol?: string;
    /**
     * A source (for ingress)/destination (for egress) of the traffic identified by a Security Group.
     */
    userSecurityGroupLists?: string[];
}

export interface SecurityGroupRulesIngress {
    /**
     * A list of source (for ingress)/destination (for egress) IP subnet (in [CIDR notation][cidr]) to match.
     */
    cidrLists?: string[];
    /**
     * A free-form text describing the Security Group rule purpose.
     */
    description?: string;
    icmpCode?: number;
    icmpType?: number;
    ids: string[];
    /**
     * A list of ports or port ranges (`start_port-end_port`).
     * * `icmpType`/`icmpCode` - An ICMP/ICMPv6 [type/code][icmp] to match.
     */
    ports?: string[];
    /**
     * The network protocol to match. Supported values are: `TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` and `ALL`.
     */
    protocol?: string;
    /**
     * A source (for ingress)/destination (for egress) of the traffic identified by a Security Group.
     */
    userSecurityGroupLists?: string[];
}

